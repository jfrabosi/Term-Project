\hypertarget{classtask__share_1_1_queue}{}\doxysection{task\+\_\+share.\+Queue Class Reference}
\label{classtask__share_1_1_queue}\index{task\_share.Queue@{task\_share.Queue}}


A queue which is used to transfer data from one task to another.  


Inheritance diagram for task\+\_\+share.\+Queue\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classtask__share_1_1_queue}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_a91ce05bf47c2634013fdb2689c2b207f}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, type\+\_\+code, size, thread\+\_\+protect=True, overwrite=False, name=None)
\begin{DoxyCompactList}\small\item\em Initialize a queue object to carry and buffer data between tasks. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_ae785bdf9d397d61729c22656471a81df}{put}} (self, item, in\+\_\+\+ISR=False)
\begin{DoxyCompactList}\small\item\em Put an item into the queue. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_af2aef1dd3eed21c4b6c2e601cb8497d4}{get}} (self, in\+\_\+\+ISR=False)
\begin{DoxyCompactList}\small\item\em Read an item from the queue. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}{any}} (self)
\begin{DoxyCompactList}\small\item\em Check if there are any items in the queue. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_af9ada059fc09a44adc9084901e2f7266}{empty}} (self)
\begin{DoxyCompactList}\small\item\em Check if the queue is empty. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_a0482d70ce6405fd8d85628b5cf95d471}{full}} (self)
\begin{DoxyCompactList}\small\item\em Check if the queue is full. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_a713321bacac5d93ecf89c4be1c15fe30}{num\+\_\+in}} (self)
\begin{DoxyCompactList}\small\item\em Check how many items are in the queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtask__share_1_1_queue_aeac8766461d55d5717dd79fede402007}\label{classtask__share_1_1_queue_aeac8766461d55d5717dd79fede402007}} 
def {\bfseries clear} (self)
\begin{DoxyCompactList}\small\item\em Remove all contents from the queue. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{classtask__share_1_1_queue_a94d0801557844c8f7dcb772ca768a1a4}{\+\_\+\+\_\+repr\+\_\+\+\_\+}} (self)
\begin{DoxyCompactList}\small\item\em This method puts diagnostic information about the queue into a string. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classtask__share_1_1_queue_a6f9d87b116eb16dba0867d3746af9f5f}\label{classtask__share_1_1_queue_a6f9d87b116eb16dba0867d3746af9f5f}} 
int {\bfseries ser\+\_\+num} = 0
\begin{DoxyCompactList}\small\item\em A counter used to give serial numbers to queues for diagnostic use. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A queue which is used to transfer data from one task to another. 

If parameter \textquotesingle{}thread\+\_\+protect\textquotesingle{} is {\ttfamily True} when a queue is created, transfers of data will be protected from corruption in the case that one task might interrupt another due to use in a pre-\/emptive multithreading environment or due to one task being run as an interrupt service routine.

An example of the creation and use of a queue is as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{import} task\_share}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{\# This queue holds unsigned short (16-\/bit) integers}}
\DoxyCodeLine{my\_queue = \mbox{\hyperlink{classtask__share_1_1_queue}{task\_share.Queue}} (\textcolor{stringliteral}{'H'}, 100, name=\textcolor{stringliteral}{"{}My Queue"{}})}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{\# Somewhere in one task, put data into the queue}}
\DoxyCodeLine{my\_queue.put (some\_data)}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{\# In another task, read data from the queue}}
\DoxyCodeLine{something = my\_queue.get ()}

\end{DoxyCode}
 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classtask__share_1_1_queue_a91ce05bf47c2634013fdb2689c2b207f}\label{classtask__share_1_1_queue_a91ce05bf47c2634013fdb2689c2b207f}} 
\index{task\_share.Queue@{task\_share.Queue}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{type\+\_\+code,  }\item[{}]{size,  }\item[{}]{thread\+\_\+protect = {\ttfamily True},  }\item[{}]{overwrite = {\ttfamily False},  }\item[{}]{name = {\ttfamily None} }\end{DoxyParamCaption})}



Initialize a queue object to carry and buffer data between tasks. 

This method sets up a queue by allocating memory for the contents and setting up the components in an empty configuration.

Each queue can only carry data of one particular type which must be chosen from the following list. The data type is specified by a one-\/letter type code which is given as for the Python {\ttfamily array.\+array} type, which can be any of the following\+: \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ }&\cellcolor{\tableheadbgcolor}\textbf{ }&\cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ }&\cellcolor{\tableheadbgcolor}\textbf{ }&\cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-3}
\endhead
{\bfseries{b}} (signed char)   &{\bfseries{B}} (unsigned char)   &8 bit integers    \\\cline{1-3}
{\bfseries{h}} (signed short)   &{\bfseries{H}} (unsigned short)   &16 bit integers    \\\cline{1-3}
{\bfseries{i}} (signed int)   &{\bfseries{I}} (unsigned int)   &32 bit integers (probably)    \\\cline{1-3}
{\bfseries{l}} (signed long)   &{\bfseries{L}} (unsigned long)   &32 bit integers    \\\cline{1-3}
{\bfseries{q}} (signed long long)   &{\bfseries{Q}} (unsigned long long)   &64 bit integers    \\\cline{1-3}
{\bfseries{f}} (float)   &{\bfseries{d}} (double-\/precision float)   &\\\cline{1-3}
\end{longtabu}



\begin{DoxyParams}{Parameters}
{\em type\+\_\+code} & The type of data items which the queue can hold \\
\hline
{\em size} & The maximum number of items which the queue can hold \\
\hline
{\em thread\+\_\+protect} & {\ttfamily True} if mutual exclusion protection is used \\
\hline
{\em overwrite} & If {\ttfamily True}, oldest data will be overwritten with new data if the queue becomes full \\
\hline
{\em name} & A short name for the queue, default {\ttfamily QueueN} where {\ttfamily N} is a serial number for the queue \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{classtask__share_1_1_base_share_aecdc98ad6b42e05f481cf3ffa5f72ad4}{task\+\_\+share.\+Base\+Share}}.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classtask__share_1_1_queue_a94d0801557844c8f7dcb772ca768a1a4}\label{classtask__share_1_1_queue_a94d0801557844c8f7dcb772ca768a1a4}} 
\index{task\_share.Queue@{task\_share.Queue}!\_\_repr\_\_@{\_\_repr\_\_}}
\index{\_\_repr\_\_@{\_\_repr\_\_}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{\_\_repr\_\_()}{\_\_repr\_\_()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+\_\+\+\_\+repr\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



This method puts diagnostic information about the queue into a string. 

It shows the queue\textquotesingle{}s name and type as well as the maximum number of items and queue size. \mbox{\Hypertarget{classtask__share_1_1_queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}\label{classtask__share_1_1_queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}} 
\index{task\_share.Queue@{task\_share.Queue}!any@{any}}
\index{any@{any}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{any()}{any()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+any (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Check if there are any items in the queue. 

Returns {\ttfamily True} if there are any items in the queue and {\ttfamily False} if the queue is empty. \begin{DoxyReturn}{Returns}
{\ttfamily True} if items are in the queue, {\ttfamily False} if not 
\end{DoxyReturn}
\mbox{\Hypertarget{classtask__share_1_1_queue_af9ada059fc09a44adc9084901e2f7266}\label{classtask__share_1_1_queue_af9ada059fc09a44adc9084901e2f7266}} 
\index{task\_share.Queue@{task\_share.Queue}!empty@{empty}}
\index{empty@{empty}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+empty (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Check if the queue is empty. 

Returns {\ttfamily True} if there are no items in the queue and {\ttfamily False} if there are any items therein. \begin{DoxyReturn}{Returns}
{\ttfamily True} if queue is empty, {\ttfamily False} if it\textquotesingle{}s not empty 
\end{DoxyReturn}
\mbox{\Hypertarget{classtask__share_1_1_queue_a0482d70ce6405fd8d85628b5cf95d471}\label{classtask__share_1_1_queue_a0482d70ce6405fd8d85628b5cf95d471}} 
\index{task\_share.Queue@{task\_share.Queue}!full@{full}}
\index{full@{full}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+full (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Check if the queue is full. 

This method returns {\ttfamily True} if the queue is already full and there is no room for more data without overwriting existing data. \begin{DoxyReturn}{Returns}
{\ttfamily True} if the queue is full 
\end{DoxyReturn}
\mbox{\Hypertarget{classtask__share_1_1_queue_af2aef1dd3eed21c4b6c2e601cb8497d4}\label{classtask__share_1_1_queue_af2aef1dd3eed21c4b6c2e601cb8497d4}} 
\index{task\_share.Queue@{task\_share.Queue}!get@{get}}
\index{get@{get}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+get (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{in\+\_\+\+ISR = {\ttfamily False} }\end{DoxyParamCaption})}



Read an item from the queue. 

If there isn\textquotesingle{}t anything in there, wait (blocking the calling process) until something becomes available. If non-\/blocking reads are needed, one should call {\ttfamily \mbox{\hyperlink{classtask__share_1_1_queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}{any()}}} to check for items before attempting to read from the queue. This is usually done in a low priority task\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{|   \textcolor{keyword}{def }some\_task ():}
\DoxyCodeLine{|       \textcolor{comment}{\# Setup}}
\DoxyCodeLine{|       \textcolor{keywordflow}{while} \textcolor{keyword}{True}:}
\DoxyCodeLine{|           \textcolor{keywordflow}{if} my\_queue.any ():}
\DoxyCodeLine{|               something = my\_queue.get ()}
\DoxyCodeLine{|               do\_something\_with (something)}
\DoxyCodeLine{|           \textcolor{comment}{\# More loop stuff}}
\DoxyCodeLine{|           \textcolor{keywordflow}{yield} 0}

\end{DoxyCode}
 
\begin{DoxyParams}{Parameters}
{\em in\+\_\+\+ISR} & Set this to {\ttfamily True} if calling from within an ISR \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtask__share_1_1_queue_a713321bacac5d93ecf89c4be1c15fe30}\label{classtask__share_1_1_queue_a713321bacac5d93ecf89c4be1c15fe30}} 
\index{task\_share.Queue@{task\_share.Queue}!num\_in@{num\_in}}
\index{num\_in@{num\_in}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{num\_in()}{num\_in()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+num\+\_\+in (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Check how many items are in the queue. 

This method returns the number of items which are currently in the queue. \begin{DoxyReturn}{Returns}
The number of items in the queue 
\end{DoxyReturn}
\mbox{\Hypertarget{classtask__share_1_1_queue_ae785bdf9d397d61729c22656471a81df}\label{classtask__share_1_1_queue_ae785bdf9d397d61729c22656471a81df}} 
\index{task\_share.Queue@{task\_share.Queue}!put@{put}}
\index{put@{put}!task\_share.Queue@{task\_share.Queue}}
\doxysubsubsection{\texorpdfstring{put()}{put()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+put (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{item,  }\item[{}]{in\+\_\+\+ISR = {\ttfamily False} }\end{DoxyParamCaption})}



Put an item into the queue. 

If there isn\textquotesingle{}t room for the item, wait (blocking the calling process) until room becomes available, unless the {\ttfamily overwrite} constructor parameter was set to {\ttfamily True} to allow old data to be clobbered. If non-\/blocking behavior without overwriting is needed, one should call {\ttfamily \mbox{\hyperlink{classtask__share_1_1_queue_a0482d70ce6405fd8d85628b5cf95d471}{full()}}} to ensure that the queue is not full before putting data into it\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{|   \textcolor{keyword}{def }some\_task ():}
\DoxyCodeLine{|       \textcolor{comment}{\# Setup}}
\DoxyCodeLine{|       \textcolor{keywordflow}{while} \textcolor{keyword}{True}:}
\DoxyCodeLine{|           \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} my\_queue.full ():}
\DoxyCodeLine{|               my\_queue.put (create\_something\_to\_put ())}
\DoxyCodeLine{|           \textcolor{keywordflow}{yield} 0}

\end{DoxyCode}
 
\begin{DoxyParams}{Parameters}
{\em item} & The item to be placed into the queue \\
\hline
{\em in\+\_\+\+ISR} & Set this to {\ttfamily True} if calling from within an ISR \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{task__share_8py}{task\+\_\+share.\+py}}\end{DoxyCompactItemize}
